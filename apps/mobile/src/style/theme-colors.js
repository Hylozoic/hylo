// Auto-generated theme-aware color system with dynamic switching
// Generated on: 2025-08-15T05:36:38.995Z
// Do not edit manually - this file is generated by configure.sh

import { useColorScheme, Platform } from 'react-native'
import { fakeAlpha } from '@hylo/presenters/colors'

// Utility function to create transparency variants
function withAlpha(hexColor, alpha) {
  if (!hexColor || !hexColor.startsWith('#')) return hexColor
  
  // Generate platform-appropriate format
  if (Platform.OS === 'ios') {
    // iOS works better with hex colors with alpha channels
    const hex = hexColor.replace('#', '')
    const r = parseInt(hex.substr(0, 2), 16)
    const g = parseInt(hex.substr(2, 2), 16)
    const b = parseInt(hex.substr(4, 2), 16)
    const alphaHex = Math.round(alpha * 255).toString(16).padStart(2, '0')
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}${alphaHex}`
  } else {
    // Android - use fakeAlpha to blend with white background for transparency effect
    return fakeAlpha(hexColor, alpha, '#ffffff')
  }
}

// Theme definitions
export const THEMES = {
  light: {
  "black": "#2a2723",
  "background": "#e7e3da",
  "midground": "#f4f2eb",
  "foreground": "#09090b",
  "selected": "#6ecf96",
  "card": "#fffdfa",
  "cardForeground": "#2a2723",
  "popover": "#ffffff",
  "popoverForeground": "#09090b",
  "primary": "#d0d0d2",
  "primaryForeground": "#000000",
  "secondary": "#00bbff",
  "secondaryForeground": "#ffffff",
  "muted": "#f4f4f5",
  "mutedForeground": "#71717a",
  "accent": "#eb8a56",
  "accentForeground": "#ffffff",
  "destructive": "#ef4444",
  "destructiveForeground": "#fafafa",
  "error": "#ef4444",
  "errorForeground": "#fafafa",
  "focus": "#40a1dd",
  "border": "#e4e4e7",
  "input": "#ffffff",
  "ring": "#09090b",
  "chart-1": "#e76e50",
  "chart-2": "#2a9d90",
  "chart-3": "#274754",
  "chart-4": "#e8c468",
  "chart-5": "#f4a462",
  "radius": "0.5rem",
  "themeBackground": "#7f7b71",
  "themeForeground": "#f9f8f6"
},
  dark: {
  "black": "#000000",
  "background": "#4d4842",
  "midground": "#5b5652",
  "foreground": "#fffdfa",
  "card": "#403b35",
  "cardForeground": "#fffdfa",
  "popover": "#09090b",
  "popoverForeground": "#fafafa",
  "primary": "#262321",
  "primaryForeground": "#fffdfa",
  "secondary": "#45b09d",
  "secondaryForeground": "#fafafa",
  "muted": "#27272a",
  "mutedForeground": "#a1a1aa",
  "accent": "#eb8a56",
  "accentForeground": "#fafafa",
  "destructive": "#7f1d1d",
  "destructiveForeground": "#fafafa",
  "error": "#ef4444",
  "errorForeground": "#fafafa",
  "border": "#27272a",
  "input": "#27272a",
  "ring": "#d4d4d8",
  "chart-1": "#2662d9",
  "chart-2": "#2eb88a",
  "chart-3": "#e88c30",
  "chart-4": "#af57db",
  "chart-5": "#e23670",
  "themeBackground": "#403b35"
}
}

// Current theme state
let currentTheme = 'light'

// Theme switching function
export function setTheme(themeName) {
  if (THEMES[themeName]) {
    currentTheme = themeName
    // Update global colors immediately
    global.COLORS = THEMES[themeName]
    global.CURRENT_THEME = themeName
  }
}

// Get current theme colors
export function getCurrentThemeColors() {
  return THEMES[currentTheme]
}

// Get specific color by name from current theme
export function getColor(colorName) {
  return THEMES[currentTheme][colorName] || null
}

// Get specific color by name and theme
export function getThemeColor(colorName, themeName = currentTheme) {
  return THEMES[themeName][colorName] || null
}

// Hook to get current theme colors
export function useThemeColors() {
  const colorScheme = useColorScheme()
  const [colors, setColors] = useState(THEMES[colorScheme] || THEMES.light)
  
  useEffect(() => {
    const theme = colorScheme || 'light'
    setColors(THEMES[theme])
    setTheme(theme) // Update global colors
  }, [colorScheme])
  
  return colors
}

// Semantic color mappings that automatically switch with theme
export const SEMANTIC_COLORS = {
  background: 'background',
  foreground: 'foreground',
  primary: 'primary',
  secondary: 'secondary',
  accent: 'accent',
  muted: 'muted',
  destructive: 'destructive',
  error: 'error',
  border: 'border',
  input: 'input',
  ring: 'ring',
  card: 'card',
  popover: 'popover',
  selected: 'selected',
  midground: 'midground',
  focus: 'focus',
  mutedForeground: 'mutedForeground',
  cardForeground: 'cardForeground',
  popoverForeground: 'popoverForeground',
  primaryForeground: 'primaryForeground',
  secondaryForeground: 'secondaryForeground',
  accentForeground: 'accentForeground',
  destructiveForeground: 'destructiveForeground',
  errorForeground: 'errorForeground',
  themeBackground: 'themeBackground',
  themeForeground: 'themeForeground'
}

// Dynamic color getters that always return current theme colors
// 
// Usage Examples:
// - Colors.background     → #e7e3da (light) or #4d4842 (dark)
// - Colors.foreground    → #09090b (light) or #fffdfa (dark)
// - Colors.foreground80  → rgba(9, 9, 11, 0.8) (light) or rgba(255, 253, 250, 0.8) (dark)
// - Colors.background30  → rgba(231, 227, 218, 0.3) (light) or rgba(77, 72, 66, 0.3) (dark)
// - Colors.selected60    → rgba(110, 207, 150, 0.6) (light) or rgba(69, 176, 157, 0.6) (dark)
//
// Transparency variants automatically convert hex colors to rgba with the specified opacity
export const Colors = new Proxy({}, {
  get(target, prop) {
    // Check for transparency variants (e.g., foreground80, background30)
    const transparencyMatch = prop.match(/^(.+?)(\d{2})$/)
    if (transparencyMatch) {
      const baseColorName = transparencyMatch[1]
      const alpha = parseInt(transparencyMatch[2]) / 100
      
      // Get the base color
      let baseColor
      if (baseColorName in SEMANTIC_COLORS) {
        baseColor = THEMES[currentTheme][SEMANTIC_COLORS[baseColorName]]
      } else {
        baseColor = THEMES[currentTheme][baseColorName]
      }
      
      if (baseColor) {
        return withAlpha(baseColor, alpha)
      }
    }
    
    // Regular color lookup
    if (prop in SEMANTIC_COLORS) {
      return THEMES[currentTheme][SEMANTIC_COLORS[prop]] || null
    }
    return THEMES[currentTheme][prop] || null
  }
})

// Initialize global colors with light theme
global.COLORS = THEMES.light
global.CURRENT_THEME = 'light'
global.THEMES = THEMES
global.setTheme = setTheme
global.getColor = getColor

// Export individual color constants for both themes
export const LIGHT_COLORS = THEMES.light
export const DARK_COLORS = THEMES.dark

// Export the main colors object
export default Colors
