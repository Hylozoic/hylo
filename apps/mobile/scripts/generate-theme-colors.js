#!/usr/bin/env node

const fs = require('fs')
const path = require('path')

// Convert HSL to Hex color
function hslToHex(hslString) {
  // Handle different HSL formats
  // Format: "42 20% 88%" or "240 10% 3.9%"
  const match = hslString.match(/(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)%?\s+(\d+(?:\.\d+)?)%?/)
  
  if (!match) {
    console.warn(`‚ö†Ô∏è  Could not parse HSL value: ${hslString}`)
    return '#000000' // fallback to black
  }
  
  const [_, h, s, l] = match
  const hue = parseFloat(h)
  const saturation = parseFloat(s) / 100
  const lightness = parseFloat(l) / 100
  
  // Convert HSL to RGB
  const c = (1 - Math.abs(2 * lightness - 1)) * saturation
  const x = c * (1 - Math.abs((hue / 60) % 2 - 1))
  const m = lightness - c / 2
  
  let r, g, b
  
  if (hue >= 0 && hue < 60) {
    [r, g, b] = [c, x, 0]
  } else if (hue >= 60 && hue < 120) {
    [r, g, b] = [x, c, 0]
  } else if (hue >= 120 && hue < 180) {
    [r, g, b] = [0, c, x]
  } else if (hue >= 180 && hue < 240) {
    [r, g, b] = [0, x, c]
  } else if (hue >= 240 && hue < 300) {
    [r, g, b] = [x, 0, c]
  } else {
    [r, g, b] = [c, 0, x]
  }
  
  // Convert to 8-bit integers and then to hex
  const rHex = Math.round((r + m) * 255).toString(16).padStart(2, '0')
  const gHex = Math.round((g + m) * 255).toString(16).padStart(2, '0')
  const bHex = Math.round((b + m) * 255).toString(16).padStart(2, '0')
  
  return `#${rHex}${gHex}${bHex}`
}

// Convert CSS property names to camelCase
function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase())
}

function generateThemeColors() {
  console.log('üé® Generating theme-aware color system...')
  
  const cssPath = path.join(__dirname, '../src/style/global.css')
  
  // Check if CSS file exists
  if (!fs.existsSync(cssPath)) {
    console.error('‚ùå CSS file not found:', cssPath)
    process.exit(1)
  }
  
  const cssContent = fs.readFileSync(cssPath, 'utf8')
  
  // Parse light and dark theme variables separately
  const lightTheme = {}
  const darkTheme = {}
  
  // Extract light theme variables (default)
  const lightMatch = cssContent.match(/:root\s*{([^}]+)}/s)
  if (lightMatch) {
    const lightContent = lightMatch[1]
    const lightRegex = /--([^:]+):\s*([^;]+);/g
    let match
    while ((match = lightRegex.exec(lightContent)) !== null) {
      const [, varName, value] = match
      const trimmedValue = value.trim()
      
      // Convert HSL to hex for React Native compatibility
      if (trimmedValue.includes('%') || (trimmedValue.includes(' ') && !trimmedValue.includes('rem'))) {
        lightTheme[toCamelCase(varName)] = hslToHex(trimmedValue)
      } else {
        // Keep non-HSL values as-is (like radius)
        lightTheme[toCamelCase(varName)] = trimmedValue
      }
    }
  }
  
  // Extract dark theme variables
  const darkMatch = cssContent.match(/\.dark\s*{([^}]+)}/s)
  if (darkMatch) {
    const darkContent = darkMatch[1]
    const darkRegex = /--([^:]+):\s*([^;]+);/g
    let match
    while ((match = darkRegex.exec(darkContent)) !== null) {
      const [, varName, value] = match
      const trimmedValue = value.trim()
      
      // Convert HSL to hex for React Native compatibility
      if (trimmedValue.includes('%') || (trimmedValue.includes(' ') && !trimmedValue.includes('rem'))) {
        darkTheme[toCamelCase(varName)] = hslToHex(trimmedValue)
      } else {
        // Keep non-HSL values as-is (like radius)
        darkTheme[toCamelCase(varName)] = trimmedValue
      }
    }
  }
  
  console.log(`üìä Found ${Object.keys(lightTheme).length} light theme colors`)
  console.log(`üìä Found ${Object.keys(darkTheme).length} dark theme colors`)
  
  // Generate theme-aware color system with dynamic switching
  const jsContent = `// Auto-generated theme-aware color system with dynamic switching
// Generated on: ${new Date().toISOString()}
// Do not edit manually - this file is generated by configure.sh

import { useColorScheme } from 'react-native'

// Theme definitions
export const THEMES = {
  light: ${JSON.stringify(lightTheme, null, 2)},
  dark: ${JSON.stringify(darkTheme, null, 2)}
}

// Current theme state
let currentTheme = 'light'

// Theme switching function
export function setTheme(themeName) {
  if (THEMES[themeName]) {
    currentTheme = themeName
    // Update global colors immediately
    global.COLORS = THEMES[themeName]
    global.CURRENT_THEME = themeName
  }
}

// Get current theme colors
export function getCurrentThemeColors() {
  return THEMES[currentTheme]
}

// Get specific color by name from current theme
export function getColor(colorName) {
  return THEMES[currentTheme][colorName] || null
}

// Get specific color by name and theme
export function getThemeColor(colorName, themeName = currentTheme) {
  return THEMES[themeName][colorName] || null
}

// Hook to get current theme colors
export function useThemeColors() {
  const colorScheme = useColorScheme()
  const [colors, setColors] = useState(THEMES[colorScheme] || THEMES.light)
  
  useEffect(() => {
    const theme = colorScheme || 'light'
    setColors(THEMES[theme])
    setTheme(theme) // Update global colors
  }, [colorScheme])
  
  return colors
}

// Semantic color mappings that automatically switch with theme
export const SEMANTIC_COLORS = {
  background: 'background',
  foreground: 'foreground',
  primary: 'primary',
  secondary: 'secondary',
  accent: 'accent',
  muted: 'muted',
  destructive: 'destructive',
  error: 'error',
  border: 'border',
  input: 'input',
  ring: 'ring',
  card: 'card',
  popover: 'popover',
  selected: 'selected',
  midground: 'midground',
  focus: 'focus',
  mutedForeground: 'mutedForeground',
  cardForeground: 'cardForeground',
  popoverForeground: 'popoverForeground',
  primaryForeground: 'primaryForeground',
  secondaryForeground: 'secondaryForeground',
  accentForeground: 'accentForeground',
  destructiveForeground: 'destructiveForeground',
  errorForeground: 'errorForeground',
  themeBackground: 'themeBackground',
  themeForeground: 'themeForeground'
}

// Dynamic color getters that always return current theme colors
export const Colors = new Proxy({}, {
  get(target, prop) {
    if (prop in SEMANTIC_COLORS) {
      return THEMES[currentTheme][SEMANTIC_COLORS[prop]] || null
    }
    return THEMES[currentTheme][prop] || null
  }
})

// Initialize global colors with light theme
global.COLORS = THEMES.light
global.CURRENT_THEME = 'light'
global.THEMES = THEMES
global.setTheme = setTheme
global.getColor = getColor

// Export individual color constants for both themes
export const LIGHT_COLORS = THEMES.light
export const DARK_COLORS = THEMES.dark

// Export the main colors object
export default Colors
`

  const outputPath = path.join(__dirname, '../src/style/theme-colors.js')
  fs.writeFileSync(outputPath, jsContent)
  
  console.log('‚úÖ Theme-aware color system generated successfully!')
  console.log(`üìÅ Output: ${outputPath}`)
  console.log(`üéØ Colors available globally as: global.COLORS`)
  console.log(`üéØ Theme switching: global.setTheme('dark') or global.setTheme('light')`)
}

// Run the generator
generateThemeColors() 